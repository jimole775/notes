# 线程同步（synchronized关键字）
synchronized的3种使用方法：
- 修饰实例方法：作用于类实例
- 修饰静态方法：作用于类对象
- 修饰代码块：指定加锁对象
``` java
// 修饰实例方法：锁的是实例对象
public synchronized void method () {}

// 修饰静态方法：锁的是类对象
public static synchronized void method () {}

// 修饰代码块：锁实例对象和类对象都可以
public void method () {
    synchronized (this) {
        // todo
    }
}
```

# 生产者vs消费者问题
可能出现的问题：
1. 生产者比消费者快时，消费者会漏掉一些数据没有取到。
2. 消费者比生产者快时，消费者取相同的数据。
当中的 `notify()` 和 `wait()` 用来协调读取关系，`notify()` 和 `wait()` 都只能从同步方法中调用。

# wait-notify 机制
- 当 `synchronized` 方法中的wait方法被调用时，当前线程将被中断运行，并且放弃该对象的锁。
- 一旦线程调用了 `wait` 方法，它便进入该对象的等待列表。要从等待列表中删除该线程，使它有机会继续运行，其他线程必须调用同一个对象上的 `notify` 或者 `notifyAll` 方法。
- 当线程再次称为可运行的线程后，它们便试图重新进入该对象。一旦可以使用该对象锁时，其中的一个线程将锁定该对象，并且从它上次调用 `wait` 方法后的位置开始继续进行。

# 使用同步机制
1. 如果两个或多个线程修改一个对象，请将执行修改的方法声明为 `synchronized` 方法。受到对象修改影响的只读方法也必须实现同步.

2. 如果一个线程必须等待某个对象的状态出现变更，那么它应该在对象的内部等待而不是在外边等待。这可以通过进入一个 `synchronized` 方法，并且调用 `wait` 方法来实现。

3. 不要在 `synchronized` 方法中花费大量的时间。大多数操作只是更新数据，然后很快返回。

4. 每当一个方法改变某个对象的状态时，它就应该调用 `notifyAll` 方法。这样可以给等待线程一个机会，以便查看环境有没有发生变化。

5. 记住，`wait` 和 `notifyAll/notify` 方法都属于 Object 类的方法，而不是 Thread 类的方法。反复检查你对 `wait` 方法的调用与统一对象上的通知是否匹配。

# 多线程的取舍
有效利用多线程的关键是理解程序是并发执行而不是串行执行的。

例如：程序中有两个子系统需要并发执行，这时候就需要利用多线程编程。

通过对多线程的使用，可以编写出非常搞笑的程序。不过请注意，如果你创建太多的线程，程序执行的效率实际上是降低了，而不是提高。

例如：如果你创建了太多的线程，CPU 花费在上下文的切换的时间将多于执行程序的时间。
