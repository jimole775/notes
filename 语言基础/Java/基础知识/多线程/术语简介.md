1. 进程：每个进程都有独立的代码和数据空间，进程间的切换会有较大的开销，一个进程包含1~n个线程.(进程是资源分配的最小单位)

2. 线程：同一类线程共享代码和数据空间，每个线程都有独立的运行栈和程序计数器（PC），线程切换开销小。（线程是CPU调度的最小单位）

3. 并行：多个CPU实例或者多台机器同时执行一段逻辑处理，是真正的同时（相对于并发是有区别的）。

4. 并发：通过CPU调度算法，让用户看上去同时执行，实际上从CPU操作层面不是真正的同时。并发往往在场景中的公用的资源，那么针对这个公用的资源往往会产生瓶颈，我们会用TPS或者QPS来反映这个系统的处理能力。

5. 线程安全：经常用来描绘一段代码。指的是在并发的情况下，该代码经过多线程使用，线程调度顺序不影响任何结果。这个时候使用多线程，我们只需要关注系统的内存，CPU是不是够用即可。反过来，线程不安全就意味着线程的调度顺序会影响最终的结果，如果不加事务的转账代码：
``` java
void transferMoney(User from, User to, float amount) {
    to.setMoney(to.getBalance() + amount);
    from.setMonry(from.getBalance() + amount);
}
```

6. 同步：Java中的同步是指通过认为的控制和调度，保证共享资源的多线程称为线程安全，来保证结果准确的同时，提高性能，才能使优秀的程序。线程安全的优化级高于性能。

7. 多线程：指的是这个程序（一个进程）运行时产生了不止一个进程。

8. 非公平所：JVM按随机、就近原则分配所的机制被称为不公平锁，ReentrantLock 在构造函数中提供了是否公平锁的初始化方式，默认为公平锁。非公平锁实际执行的效率要远远超出公平锁，除非程序有特殊需要，否则最常用非公平锁的分配机制。

9. 公平锁：公平锁指的是锁的分配机制是公平的，通常先对锁提出获取请求的线程会被分配到锁，ReentrantLock在构造函数中提供了是否公平锁的初始化方式来定义公平锁。