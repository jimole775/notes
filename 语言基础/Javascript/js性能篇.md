1. 除了 `for in`, 其他形式的循环体性能都几乎差不多

   使用 `for in` 遍历属性或者下标的时候 `必须` 使用 `hasOwnProperty` 方法确定是对象实例的属性，否则速度将会慢上1倍（chrome中循环100W次）

   for in 相对于 forEach 方法 `慢2-3倍`（chrome中循环100W次）

   使用for循环相对于 forEach 对数组的遍历，`快0.5倍`（chrome中循环100W次）

   **结论**：`for > forEach > for in`

2. 大多数情况, 如果要遍历数组或者对象属性, 一般都会先用 `字面量` 或者 `局部变量` 的形式获取长度, 这样会比每次都计算数组或对象的长度省时许多


3. 执行倒序循环 总体 比正序操作量少

   `exp: for(var i = item.length, i --){}` // 这样的循环少了一部操作就是：不用比对 i值和数组长度的大小

4. `基于函数` 的循环体要比 `基于循环` 的循环体要 `慢8倍`

   **tips**: 所以，如果对于性能有考虑的话应该使用 for, while 而不要使用原生的forEach()

5. 如无必要, 尽量创建局部变量, 不仅是因为维护的原因, 也和性能有关

   **实验证明**：创建 `N个` gobal对象 会比 把所有对象当成 `1个` gobal对象的属性，消耗的时间 `多一倍`；因为涉及到 `预加载`，所有gobal对象都会进行预加载，而gobal下的属性不会

6. `document.write`和直接把标签写进body消耗的时间差不多

7. 尽量减少直接创建全局对象（window）

   **在IE8的测试**：对window的全局对象访问 `10W次`，需要消耗2-3秒的间；而只访问同一个全局对象下次级对象，只消耗了 `200-300毫秒`，也就是10倍的差距

8. 如果能准确的知道键名, 使用一个对象做MAP比使用一个数组做MAP要高效N倍
``` js
   obj["key"] // 消耗0ms

   // 消耗 N ms
   ary.forEach(function(item) {
      if (item == ary[key]) return item
   })
```

9. undefined和null

- undefined 代表未定义，已经申请栈内存，并进行了一定的初始化，但是没有指向堆对象

- null 代表空或者置空，可以理解为，已经申请了栈内存，但没有初始化，也没有指向堆对象

- 按照这么推断：null所占字节数小于undefined的
