# JVM 的组成架构
java 是一种跨平台语言，JVM 屏蔽了底层系统的不同，为 Java 字节码文件构造了一个统一的运行环境。

- 类加载器 => 类文件

- 运行期数据区 => 方法区（共享）、堆区（共享）、栈区（独占）、程序计数寄存器（独占）

- 执行引擎

# 类加载器的双亲委托模型
低层次的当前类加载器，不能覆盖更高层次类加载器已经加载的类，如果低层次的类加载器想加载一个未知类，需要上级类加载器确认，只有当上级类加载器没有加载过这个类，也允许加载的时候，才让当前类加载器加载这个未知类。

# 自定义类加载器
> 为什么我们要去自己写一个加载器？
- 隔离加载类：同一个 jvm 中不同组件加载同一个类的不同版本。
- 扩展加载源：从网络、数据库等处加载字节码。
- 字节码加密：加载自定义的加密字节码，在 ClassLoader 中解密。

# 堆 & 栈
- 堆：每个 JVM 实例唯一对应一个堆，应用程序在运行中所创建的所有类实例或数组都放在这个堆中，并由应用所有的线程共享。

- 堆栈：JVM 为每个新创建的线程都分配一个堆栈，也就是说，对于一个 java 程序来说，它的运行就是通过对堆栈的操作来完成。

Java 中所有对象的存储空间都是在堆中分配的，但是这个对象的引用却是在堆栈中分配，也就是说在建立一个对象时，从两个地方都分配内存，在堆中分配的内存实际建立这个对象，而在堆栈中分配的内存只是一个指向这个堆对象的引用而已。

# 方法区 & 程序计数器
方法区主要存放从磁盘加载进来的类字节码，而在程序运行过程中创建的类实例则存放在堆里。

程序运行的时候，实际上是以线程为单位运行的，当JVM进入启动类的 main 方法的时候，就会为应用程序创建一个主线程，main 方法里的代码就会被这个主线程执行，每个线程有自己的 java 栈，栈里存放着方法运行期的局部变量。而当前线程执行到哪一行字节码指令，这个信息则被存放在程序计数寄存器。