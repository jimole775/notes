> 锁本身也有临界区问题（多个线程同时获取到了一个锁），为了实现互斥锁，需要使用锁原语CAS

# 锁原语 CAS（V,E,N）
- V 表示要更新的变量
- E 表示预期值
- N 表示新值

如果 V 值等于 E 值，则将 V 的值设为 N，若 V 值和 E 值不同，什么都不做。

CAS 是一种系统原语，原语的执行必须是连续的，在执行过程中不允许被中断，所以锁就不会被两个以上线程占用。

# 锁状态（需要了解以下几个锁的实现原理）
1. 正常锁
2. 偏向锁：指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。
3. 轻量级锁：指当锁是偏向锁时，被另一个线程锁访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。
4. 重量级锁：指当锁是轻量级锁时，另一个线程虽然自旋，但自旋不会一直持续下去，当自旋到一定次数时，还没获取到锁，就会进入阻塞，该锁膨胀为重量级锁，重量级锁会让其他申请的线程进入阻塞，性能降低。

> java 通过 CAS 原语在对象头中修改 **Mark Work** 实现加锁

# 总线锁与缓存锁（针对多CPU同时运行的锁问题）
1. 总线锁：使用处理器的 LOCK# 信号，当一个处理器在内存总线上输出此信号的时候，其他处理器的请求将被阻塞，该处理器独占内存。
2. 缓存锁：是指内存区域如果被缓存在处理器的缓存行中，并且在 Lock 操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不再总线上声言 LOCK# 信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会组织同时修改由 两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行数据时，会使缓存行无效。

> 总线锁会导致性能下降

# 各种锁
1. 公平锁：多个线程按照申请锁的顺序来获取锁的

2. 非公平锁：非公平锁就是多个线程获取锁的顺序并不是按照申请锁的顺序，由可能后申请的线程比先申请的线程优先获取锁，可能会造成饥饿现象。

3. 可重入锁：可重入锁就是说某个线程已经获得某个锁，可以再次获取锁而不会出现死锁。

4. 独享锁/互斥锁：该锁一次只能被一个线程锁持有

5. 共享锁：该锁可以被多个线程所持有

6. 读写锁：多个读线程之间并不互斥，而写线程则要求与任何线程互斥

7. 悲观锁：悲观锁认为对于同一个数据的并发操作，一定会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取枷锁的形式。悲观的认为，不加锁的并发操作一定会出现问题。

8. 乐观锁：乐观锁认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，检查是否已经被修改过，如果修改过，就放弃。

9. 分段锁：分段所的设计目的是细化所的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组的一段进行加锁操作。 `JSK ConcurrentHashMap` 是通过分段锁的形式来实现搞笑并发操作的。

10. 自旋锁：自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。
